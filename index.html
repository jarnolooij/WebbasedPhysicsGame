<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clickable Dice Roll</title>
<style>
  body { margin: 0; overflow: hidden; background: #686868; font-family: Arial, sans-serif; }
  #ui-card {
    position: absolute;
    top: 20px;
    left: 20px;
    width: 200px;
    padding: 15px;
    background: rgba(255,255,255,0.9);
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
    z-index: 10;
  }
  #ui-card button, #ui-card input {
    width: 100%;
    padding: 6px;
    margin-bottom: 6px;
    font-size: 14px;
    box-sizing: border-box;
  }
</style>
</head>
<body>

<div id="ui-card">
  <h3>Dice Spawner</h3>
  <button id="spawnD6Btn">Spawn D6</button>
  <button id="spawnCustomBtn">Spawn Custom Dice</button>
  <input type="text" id="face1" placeholder="Face 1">
  <input type="text" id="face2" placeholder="Face 2">
  <input type="text" id="face3" placeholder="Face 3">
  <input type="text" id="face4" placeholder="Face 4">
  <input type="text" id="face5" placeholder="Face 5">
  <input type="text" id="face6" placeholder="Face 6">
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x686868);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(65, 65, 65);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffffff,1);
dirLight.position.set(100,200,100);
dirLight.castShadow = true;
scene.add(dirLight);

// Field
const fieldGeometry = new THREE.BoxGeometry(150,1,150);
const fieldMaterial = new THREE.MeshStandardMaterial({ color: 0x6aa84f });
const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
field.position.y = 0.5;
scene.add(field);

const diceArray = [];

// Helper: create bright white texture for a dice face
function createFaceTexture(text){
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff'; // bright white
    ctx.fillRect(0,0,256,256);
    ctx.fillStyle = '#000000'; // fully black text
    ctx.font = 'bold 150px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text,128,128);
    return new THREE.CanvasTexture(canvas);
}

// Helper: create a dice material using MeshBasicMaterial (ignores lighting)
function createDiceMaterial(text){
    return new THREE.MeshBasicMaterial({
        map: createFaceTexture(text),
        color: 0xffffff
    });
}

// Spawn D6
function spawnD6(){
    const diceSize = 7;
    const materials = [];
    for(let i=1;i<=6;i++) materials.push(createDiceMaterial(i.toString()));
    const geometry = new THREE.BoxGeometry(diceSize,diceSize,diceSize);
    const dice = new THREE.Mesh(geometry,materials);
    const offset = diceArray.length * 12;
    dice.position.set(offset, field.position.y + 0.5 + diceSize/2, 0);
    scene.add(dice);
    diceArray.push(dice);
}

// Spawn Custom Dice
function spawnCustomDice(){
    const diceSize = 10;
    const faces = [];
    for(let i=1;i<=6;i++){
        const val = document.getElementById(`face${i}`).value || i.toString();
        faces.push(val);
    }
    const materials = faces.map(f => createDiceMaterial(f));
    const geometry = new THREE.BoxGeometry(diceSize,diceSize,diceSize);
    const dice = new THREE.Mesh(geometry,materials);
    const offset = diceArray.length * 12;
    dice.position.set(offset, field.position.y + 0.5 + diceSize/2, 0);
    scene.add(dice);
    diceArray.push(dice);
}

// Raycaster for clicks
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function onMouseClick(event){
    mouse.x = (event.clientX / window.innerWidth)*2 - 1;
    mouse.y = - (event.clientY / window.innerHeight)*2 + 1;

    raycaster.setFromCamera(mouse,camera);
    const intersects = raycaster.intersectObjects(diceArray);
    if(intersects.length>0){
        const dice = intersects[0].object;
        rollDice(dice);
    }
}

// Roll dice by random rotation
function rollDice(dice){
    const deg90 = Math.PI/2;
    dice.rotation.x = deg90 * Math.floor(Math.random()*4);
    dice.rotation.y = deg90 * Math.floor(Math.random()*4);
    dice.rotation.z = deg90 * Math.floor(Math.random()*4);
}

// Event listener
window.addEventListener('click',onMouseClick);

// Button listeners
document.getElementById('spawnD6Btn').addEventListener('click', spawnD6);
document.getElementById('spawnCustomBtn').addEventListener('click', spawnCustomDice);

// Render loop
function animate(){
    requestAnimationFrame(animate);
    renderer.render(scene,camera);
}
animate();

// Resize handler
window.addEventListener('resize',()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
