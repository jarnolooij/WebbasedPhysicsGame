<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Draggable & Clickable Dice</title>
<style>
  body { margin: 0; overflow: hidden; background: #686868; font-family: Arial, sans-serif; }
  #ui-card {
    position: absolute;
    top: 20px;
    left: 20px;
    width: 200px;
    padding: 15px;
    background: rgba(255,255,255,0.9);
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
    z-index: 10;
  }
  #ui-card button, #ui-card input {
    width: 100%;
    padding: 6px;
    margin-bottom: 6px;
    font-size: 14px;
    box-sizing: border-box;
  }
</style>
</head>
<body>

<div id="ui-card">
  <h3>Dice Spawner</h3>
  <button id="spawnD6Btn">Spawn D6</button>
  <button id="spawnCustomBtn">Spawn Custom Dice</button>
  <input type="text" id="face1" placeholder="Face 1">
  <input type="text" id="face2" placeholder="Face 2">
  <input type="text" id="face3" placeholder="Face 3">
  <input type="text" id="face4" placeholder="Face 4">
  <input type="text" id="face5" placeholder="Face 5">
  <input type="text" id="face6" placeholder="Face 6">
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x686868);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(65, 65, 65);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffffff,1);
dirLight.position.set(100,200,100);
dirLight.castShadow = true;
scene.add(dirLight);

// Field
const fieldGeometry = new THREE.BoxGeometry(150,1,150);
const fieldMaterial = new THREE.MeshStandardMaterial({ color: 0x6aa84f });
const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
field.position.y = 0.5;
scene.add(field);

// Dice storage
const diceArray = [];
const activeAnimations = [];
let draggedDice = null;

// Plane for dragging
const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const offset = new THREE.Vector3();
const intersection = new THREE.Vector3();
let isDragging = false;

// Helper: create dice texture
function createFaceTexture(text){
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,256,256);
    ctx.fillStyle = '#000000';
    ctx.font = 'bold 150px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text,128,128);
    return new THREE.CanvasTexture(canvas);
}

// Dice material
function createDiceMaterial(text){
    return new THREE.MeshBasicMaterial({
        map: createFaceTexture(text),
        color: 0xffffff
    });
}

// Spawn D6
function spawnD6(){
    const diceSize = 7;
    const materials = [];
    for(let i=1;i<=6;i++) materials.push(createDiceMaterial(i.toString()));
    const geometry = new THREE.BoxGeometry(diceSize,diceSize,diceSize);
    const dice = new THREE.Mesh(geometry,materials);
    const offsetPos = diceArray.length * 12;
    dice.position.set(offsetPos, field.position.y + 0.5 + diceSize/2, 0);
    scene.add(dice);
    diceArray.push(dice);
}

// Spawn Custom Dice
function spawnCustomDice(){
    const diceSize = 7;
    const faces = [];
    for(let i=1;i<=6;i++){
        const val = document.getElementById(`face${i}`).value || i.toString();
        faces.push(val);
    }
    const materials = faces.map(f => createDiceMaterial(f));
    const geometry = new THREE.BoxGeometry(diceSize,diceSize,diceSize);
    const dice = new THREE.Mesh(geometry,materials);
    const offsetPos = diceArray.length * 12;
    dice.position.set(offsetPos, field.position.y + 0.5 + diceSize/2, 0);
    scene.add(dice);
    diceArray.push(dice);
}

// Mouse events for drag & click
function onMouseDown(event){
    mouse.x = (event.clientX / window.innerWidth)*2 - 1;
    mouse.y = - (event.clientY / window.innerHeight)*2 + 1;
    raycaster.setFromCamera(mouse,camera);
    const intersects = raycaster.intersectObjects(diceArray);
    if(intersects.length>0){
        draggedDice = intersects[0].object;
        isDragging = false;
        plane.setFromNormalAndCoplanarPoint(new THREE.Vector3(0,1,0), new THREE.Vector3(0, draggedDice.position.y,0));
        raycaster.ray.intersectPlane(plane, intersection);
        offset.copy(intersection).sub(draggedDice.position);
    }
}

function onMouseMove(event){
    if(draggedDice){
        isDragging = true;
        mouse.x = (event.clientX / window.innerWidth)*2 - 1;
        mouse.y = - (event.clientY / window.innerHeight)*2 + 1;
        raycaster.setFromCamera(mouse,camera);
        if(raycaster.ray.intersectPlane(plane, intersection)){
            draggedDice.position.copy(intersection.sub(offset));
            draggedDice.position.y = field.position.y + 0.5 + 7/2;
        }
    }
}

function onMouseUp(event){
    if(draggedDice && !isDragging){
        // Click without drag â†’ roll animation
        startRollAnimation(draggedDice);
    }
    draggedDice = null;
    isDragging = false;
}

// Roll animation
function startRollAnimation(dice){
    const deg90 = Math.PI/2;
    const targetRotation = {
        x: deg90 * Math.floor(Math.random()*4),
        y: deg90 * Math.floor(Math.random()*4),
        z: deg90 * Math.floor(Math.random()*4)
    };
    const jumpHeight = 15;
    const jumpFrames = 20;
    const rotationFrames = 20;
    const startY = dice.position.y;
    let frame = 0;
    activeAnimations.push({
        dice,
        frame,
        jumpFrames,
        rotationFrames,
        startY,
        jumpHeight,
        targetRotation
    });
}

// Animate dice
function animate(){
    requestAnimationFrame(animate);

    for(let i = activeAnimations.length - 1; i >= 0; i--){
        const anim = activeAnimations[i];
        const t = anim.frame / anim.jumpFrames;

        // parabolic jump
        anim.dice.position.y = anim.startY + anim.jumpHeight * 4 * t * (1 - t);

        // smooth rotation
        anim.dice.rotation.x += (anim.targetRotation.x - anim.dice.rotation.x) / anim.rotationFrames;
        anim.dice.rotation.y += (anim.targetRotation.y - anim.dice.rotation.y) / anim.rotationFrames;
        anim.dice.rotation.z += (anim.targetRotation.z - anim.dice.rotation.z) / anim.rotationFrames;

        anim.frame++;
        if(anim.frame > anim.jumpFrames){
            anim.dice.position.y = anim.startY;
            anim.dice.rotation.x = anim.targetRotation.x;
            anim.dice.rotation.y = anim.targetRotation.y;
            anim.dice.rotation.z = anim.targetRotation.z;
            activeAnimations.splice(i,1);
        }
    }

    renderer.render(scene,camera);
}
animate();

// Event listeners
window.addEventListener('mousedown',onMouseDown);
window.addEventListener('mousemove',onMouseMove);
window.addEventListener('mouseup',onMouseUp);
document.getElementById('spawnD6Btn').addEventListener('click', spawnD6);
document.getElementById('spawnCustomBtn').addEventListener('click', spawnCustomDice);

// Resize
window.addEventListener('resize',()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
